# Informe Pentesting

# Parte 1 - SQLi
## a) SQLi error inicio de sesión
En el campo "User" del formulario de inicio de sesión de la página `list_players.php`, la consulta SQL que se ejecuta es vulnerable a un ataque de inyección SQL. Por ejemplo, si usamos la doble comilla `"`: 

![Imagen 1](/img/1.png)

Pulsamos en login y nos muestra el error obtenido: 
![Imagen 2](/img/2.png)

El código actual ejecuta la consulta SQL de la siguiente manera:
```php
SELECT userId, password FROM users WHERE username = 'user_input' AND password = 'password_input'
```

Este método es inseguro porque permite a un atacante manipular la consulta inyectando código SQL malicioso en los campos de entrada del formulario.

**Campos afectados:**
- Campo de entrada utilizado: `User`
- Campo no utilizado en la consulta: `Password`

<br>

---

## b) Ataque de diccionario para impersonar usuarios
El ataque de diccionario consiste en probar diversas combinaciones de contraseñas usando la inyección SQL. Un atacante puede utilizar un payload en el campo de User para realizar intentos de login con contraseñas conocidas del diccionario.

**Payload Utilizado:**
```
" OR password="1234" --
```

![Imagen 3](/img/3.png)

Al introducir el Payload que funciona, podemos ver como iniciamos sesión en la página:
![Imagen 4](/img/4.png)


Para comprobar el nombre del usuario con el que hemos iniciado sesión pensé en buscar en las cookies, pero no nos lo mostraba:
![Imagen 5](/img/5.png)

Para saber el nombre finalmente lo que hice fue hacer un comentario en uno de los jugadores, al hacer el comentario y mostrarlo, podíamos ver el nombre del usuario que introdujo dicho comentario.

Estos son los comentarios antes de realizar el mío:

![Imagen 6](/img/6.png)

<br>
El comentario realizado:

![Imagen 7](/img/7.png)

<br>
Los comentarios actualizados donde podemos ver el nombre del usuario:

![Imagen 8](/img/8.png)

Podemos comprobar que el nombre de usuario es luis, es decir, podemos iniciar sesión con el nombre luis y la contraseña descubierta con anterioridad.

<br>

---

## c) Vulnerabilidad en SQLite3::escapeString() y solución
La función `SQLite3::escapeString()` utilizada en el código para sanitizar la entrada del usuario no es suficiente para evitar inyecciones SQL. Aunque la función escapa ciertos caracteres, el uso de concatenación directa de cadenas sigue siendo vulnerable.

Se debe modificar el código para usar consultas preparadas, lo que garantizará que los parámetros sean tratados de manera segura:
Antes:
```php
$sql = "SELECT userId FROM users WHERE username = '" . $username . "' AND password = '" . $password . "'";
```

Después (solución con consultas preparadas):
```php
$stmt = $db->prepare('SELECT userId FROM users WHERE username = ? AND password = ?');
$stmt->bindValue(1, $username, SQLITE3_TEXT);
$stmt->bindValue(2, $password, SQLITE3_TEXT);
$result = $stmt->execute();
```

## d) Publicar comentarios en nombre de otros usuarios mediante vulnerabilidades
El formulario de comentarios permite la inyección de código malicioso debido a la falta de validación y escape de las entradas del usuario. A pesar de usar `SQLite3::escapeString()`, el código no protege completamente contra la inyección de HTML o JavaScript en los comentarios, lo que podría permitir realizar ataques como XSS.

He intentado hacer comentarios en nombre de otros usuarios, tratando de cambiar los valores de las cookies, pero de cualquier manera, seguían saliendo siempre que los comentarios han sido realizados por luis:


<br>

---

# Parte 2 - XSS
## a) Crear un comentario con un alert de JavaScript
En el formulario de comentarios de `add_comment.php`, se puede insertar código JavaScript malicioso en el campo de texto del comentario, lo que se ejecutará cuando otro usuario visualice el comentario.

**Payload Utilizado:**
```html
<script>alert('¡Vulnerabilidad XSS!');</script>
```
![Imagen 9](/img/9.png)

Una vez ponemos el comentario debemos pulsar en `show/add comments`:

![Imagen 10](/img/10.png)

Nos debe mostrar un mensaje como el siguiente:

![Imagen 11](/img/11.png)

Y si vemos los comentarios, este saldrá en blanco:

![Imagen 12](/img/12.png)

<br>

---

## b) Explicación del uso de & en lugar de & en enlaces GET
El uso de &amp; en lugar de & en enlaces GET es necesario porque el símbolo & tiene un significado especial en HTML (se utiliza para separar parámetros). Al usar &amp;, nos aseguramos de que el navegador interprete correctamente el símbolo como un ampersand literal y no como el inicio de una entidad HTML.

<br>

---

## c) Vulnerabilidad en show_comments.php y corrección
El código de `show_comments.php` no escapa adecuadamente el contenido de los comentarios, lo que permite la inyección de JavaScript malicioso.

Para solucionarlo se debe modificar el código de la página para usar `htmlspecialchars()` al mostrar los comentarios:

Antes:
```php
echo "<div><h4>" . $row['username'] . "</h4><p>commented: " . $row['body'] . "</p></div>";
```

Después:
```php
echo "<div><h4>" . $row['username'] . "</h4><p>commented: " . htmlspecialchars($row['body'], ENT_QUOTES, 'UTF-8') . "</p></div>";
```

<br>

---

## d) Identificar otras páginas afectadas por XSS y análisis
Otras páginas afectadas:
- `buscador.html`
- `insert_player.php`

Al revisar el código de estas páginas, se observó que no se validaban ni escapaban adecuadamente las entradas del usuario, lo que permitió que los scripts fueran ejecutados al ser mostrados en la página.

<br>

---

# Parte 3 - Control de acceso, autenticación y sesiones de usuarios
## a) Medidas de seguridad para evitar un registro inseguro
### SQL Injection:
El código es vulnerable a ataques de inyección SQL, ya que utiliza concatenación de cadenas para insertar datos directamente en la consulta SQL. Esto puede ser aprovechado por un atacante para manipular la consulta y obtener acceso no autorizado a la base de datos. Para tratar de solucionarlo se deben utilizar consultas preparadas y parámetros vinculados, que aseguran que los datos sean tratados correctamente y no como parte de la consulta SQL.

**Código cambiado:**
```php
$stmt = $db->prepare('SELECT userId, password FROM users WHERE username = :username');
$stmt->bindValue(':username', $user, SQLITE3_TEXT);
$result = $stmt->execute();
```

<br>

---

### Contraseñas en texto claro:
El código actual almacena las contraseñas en texto claro, lo que las hace vulnerables en caso de una filtración de la base de datos. Para proteger las contraseñas, se debe utilizar un algoritmo de hash seguro, como `password_hash()` en lugar de almacenar la contraseña directamente.

**Código cambiado:**
```php
if (password_verify($password, $row['password'])) {
```

<br>

---

### Fuerza bruta:
El sistema actual no tiene protección contra ataques de fuerza bruta o bots que intenten registrar usuarios de manera automática. Por lo que el acceso a register.php debe ser restringido a ciertos roles de usuario, y se deben implementar medidas de seguridad como CAPTCHA y validaciones en el lado del servidor.

**Código cambiado:**
```php
$hashed_password = password_hash($password, PASSWORD_BCRYPT);
$stmt = $db->prepare("INSERT INTO users (username, password) VALUES (:username, :password)");
$stmt->bindValue(':username', $username, SQLITE3_TEXT);
$stmt->bindValue(':password', $hashed_password, SQLITE3_TEXT);
$stmt->execute();
```

<br>

---

## b) Medidas de seguridad para asegurar el login


## c) Restricciones para el acceso a register.php


## d) Configuración de la carpeta private para evitar acceso no autorizado




## e) Análisis y aseguramiento del flujo de sesiones de usuarios


<br>

---

# Parte 4 - Servidores web
## Punto 1: Configuración del Servidor Web
Para minimizar el riesgo de ataques en el servidor web, es posible implementar medidas que abarcan tanto la configuración del sistema operativo, como políticas organizativas y ajustes técnicos más específicos.

## Punto 1: Configuración del Servidor Web
Es esencial deshabilitar módulos o servicios que no sean necesarios, disminuyendo así la superficie de ataque. Además, se debe ocultar información sensible del servidor configurando opciones como ServerTokens a Prod y ServerSignature a Off.

---
## Punto 2: Seguridad de las Conexiones
Es fundamental habilitar HTTPS para garantizar que todas las comunicaciones estén encriptadas mediante certificados SSL/TLS. Además, se debe implementar HTTP Strict Transport Security (HSTS) para obligar a los navegadores a realizar únicamente conexiones seguras.

---
## Punto 3: Control de Acceso
Se debe implementar autenticación de dos factores (2FA), añadiendo una capa adicional de protección para los usuarios. Además, la instalación de un cortafuegos de aplicaciones web (WAF) ayudaría a bloquear automáticamente patrones de tráfico malintencionado.

---
## Punto 4: Cabeceras HTTP de Seguridad
La configuración de cabeceras HTTP protege las aplicaciones web frente a amenazas comunes. La cabecera Content-Security-Policy limita los orígenes de scripts y recursos para prevenir ataques de XSS. Otras cabeceras esenciales incluyen X-Frame-Options para evitar ataques de clickjacking, X-Content-Type-Options para evitar la interpretación incorrecta de tipos MIME, y Referrer-Policy para controlar la información de referencia que se envía a otros sitios.

---
## Punto 5: Protección contra Ataques Comunes
Para mitigar ataques de fuerza bruta, es importante limitar el número de intentos de inicio de sesión. La protección contra inyección SQL se logra utilizando consultas preparadas en lugar de concatenar cadenas SQL. Para prevenir ataques XSS, se deben escapar adecuadamente los datos de entrada y salida.

---
## Punto 6: Registro y Monitorización
Habilitar logs detallados de errores y accesos es crucial para detectar actividades sospechosas. Estos registros deben ser supervisados constantemente mediante herramientas de monitoreo y alertas que permitan una respuesta rápida ante incidentes.

---
## Punto 7: Parcheado y Actualización
El servidor web debe mantenerse actualizado con los últimos parches de seguridad. Esto incluye además del software principal (Apache o Nginx) todas las bibliotecas y dependencias utilizadas por la aplicación web. Mantener todo actualizado reduce el riesgo de vulnerabilidades conocidas.

---
## Punto 8: Configuración de Bases de Datos
El servidor web no debe tener acceso directo con privilegios de administrador a las bases de datos. Las aplicaciones deben operar con cuentas que tengan permisos mínimos para realizar sus tareas.


<br>

---


# Parte 5 - CSRF
## a) Botón Profile con formulario malicioso en list_players.php

## b) Creación de un comentario para un ataque CSRF sin interacción del usuario

## c) Condiciones necesarias para que el ataque funcione

## d) Blindaje contra CSRF usando POST y ataque alternativo